<meta charset="utf-8">                       <!-- Markdeep: https://casual-effects.com/markdeep/ -->


                             **LSON: Lucid Serialized Object Notation**
                                        v0.1.2 / 2019-08-05



Overview
====================================================================================================
LSON is a data representation that aims for simplicity and expressiveness of JSON, but differs
in the following ways:

  + It's intended to be both concise and readable by humans as well as computers. It supports
    comments. Items are optionally terminated by whitespace, end delimiters, commas, or semi-colons.

  + It does not aim to mirror JavaScript, and thus is not a JavaScript subset. At the same time,
    LSON is a superset of JSON: any legal JSON file is legal LSON.

  + LSON is focused on data _representation_, not data _usage_. With the single exception of string
    values, there is no intrinsic support for numbers, boolean, or any other primitive type.

  + LSON supports arbitrary _elements_: domain-specific data values with declared or unknown type.
    Elements provide support for arbitrary domain-specific values, such as `true`, `null`,
    `infinity`, `2018-07-02`, `#6b17ec`, `0x1138`, `(x,a,b) => { a &lt;= x && x &lt;= b }` and so
    forth. LSON encoders and decoders handle both known and unknown types in a consistent and
    predictable manner.

  + LSON supports four intrinsic data structures:
    - array
    - dictionary (a set of name-value pairs)
    - table
    - graph



LSON Example
====================================================================================================
The following is an LSON snippet to illustrate various aspects of the notation, before we dive
deeper:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    // Comments are C-style: double slash to end of line, or enclosed with `/*` and `*/`.
    /* This is an example using slash-star delimeters. */

    // Items may be terminated with whitespace, commas, semi-colons, or object/array terminators.

    {
        index: {
            'Gloss Div': {                // There are six legal string-delimeter pairs.
                title: "S"                // No need to quote strings that lack whitespace.
                "Gloss List": {
                    `Gloss Entry`: {
                        ID:      x112-223
                        SortAs:  SGML
                        Acronym: SGML
                        «Gloss Term»: "Standard Generalized Markup Language"

                        Abbrev: (ISO: 8879:1986)  // Element of some type "ISO", value "8879:1986"

                        ‘Gloss Def’: {
                            para: "A meta-markup language, used to create markup languages "
                                + "such as DocBook."

                            “Gloss SeeAlso”: [ 'GML', 'XML', 'HTML' ]
                            'Gloss See': "markup"
                        }
                    }
                }
            }
            EntryCount: (count32:1123)      // Element of some type "count32", value "1123"

            // Table
            Content: [#
              [ Term                ; Pages           ; 'See Also'       ]
              //--------------------;-----------------;------------------;
                "ABC Dry-Clean Pad" ; (30)            ; null             ;
                "Abstract grids"    ; (46-58, 92-104) ; "Gridded Layout" ;
                "Abstract ideas"    ; (37-38, 74-77)  ; null             ;
                "Acceleration"      ; (408-409)       ; Velocity         ;
                // ...
            #]
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



File Structure
====================================================================================================

Whitespace
----------------------------------------------------------------------------------------------------
LSON whitespace includes all standard [Unicode whitespace][] characters.

    | Unicode |   Escape   | Description
    |:-------:|:----------:|:-----------
    | U+0009  |    `\t`    | Tab
    | U+000a  |    `\n`    | Newline, or line feed
    | U+000b  |  `\u{0b}`  | Vertical tab
    | U+000c  |    `\f`    | Form feed
    | U+000d  |    `\r`    | Carriage return
    | U+0020  |  `\u{20}`  | Standard space character
    | U+0085  |  `\u{85}`  | Next line
    | U+00a0  |  `\u{a0}`  | No-break space
    | U+1680  | `\u{1680}` | Ogham space mark
    | U+2000  | `\u{2000}` | En quad
    | U+2001  | `\u{2001}` | Em quad (mutton quad)
    | U+2002  | `\u{2002}` | En space (nut)
    | U+2003  | `\u{2003}` | Em space (mutton)
    | U+2004  | `\u{2004}` | Three-per-em-space (thick space)
    | U+2005  | `\u{2005}` | Four-per-em-space (mid space)
    | U+2006  | `\u{2006}` | Six-per-em-space
    | U+2007  | `\u{2007}` | Figure space
    | U+2008  | `\u{2008}` | Punctuation space
    | U+2009  | `\u{2009}` | Thin space
    | U+200a  | `\u{200a}` | Hair space
    | U+2028  | `\u{2028}` | Line separator
    | U+2029  | `\u{2029}` | Paragraph separator
    | U+202f  | `\u{202f}` | Narrow no-break space
    | U+205f  | `\u{205f}` | Medium mathematical space
    | U+3000  | `\u{3000}` | Ideographic space


Terminators
----------------------------------------------------------------------------------------------------
Each item in a sequence must be terminated with whitespace, a closing delimeter of some kind, or
with a comma (`,`) or semi-colon (`;`). Though not technically whitespace, commas and semi-colons
serve the same role in separating values, and are treated equivalently.

Since commas and semi-colons are parsed as whitespace, they are not interpreted in any syntactically
meaningful way. For example, the sequence `a,,,,b,,c` is interpreted as three items `a`, `b`, and
`c`.

Terminating values with commas or semi-colons is completely optional, and is supported only as an
aid to readability, at the discretion of the author.


Comments
----------------------------------------------------------------------------------------------------
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    // Single line comments run from double forward slashes to end of line.

    /* Slash-star comments:
    this is probably
    the best form
    for block comments. */
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Data Values
====================================================================================================

Strings
----------------------------------------------------------------------------------------------------
Strings are the only natively-supported element type (more on LSON elements later).

In addition to standard double quotes, strings may be quoted with any of five additional quote
delimiter pairs. This provides a clean way to avoid the necessity of escaping delimiters in most
complex strings.

    |    Quotes    | Character Codes | Description                                       |
    |:------------:|:---------------:|:--------------------------------------------------|
    |  `"string"`  |     U+0022      | Quotation Mark                                    |
    |  `'string'`  |     U+0027      | Apostrophe                                        |
    |  `“string”`  | U+201c, U+201d  | {Left,Right} Double Quotation Mark                |
    |  `‘string’`  | U+2018, U+2019  | {Left,Right} Single Quotation Mark                |
    |  `«string»`  | U+00ab, U+00bb  | {Left,Right}-Pointing Double Angle Quotation Mark |
    |````string````|     U+0060      | Backtick – **raw strings only**                   |

The last form, using backticks, expresses a _raw string_. Raw strings are interpreted literally,
with no processing of escape sequences (see the following section on escape sequences). The one
exception is the escape `\````, which may be used to specify a backtick within a raw string, like
so:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    `This is a \`test\`\n of the emergency\n broadcast system. \u26a0`
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

which would yield the following string:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    This is a `test`\n of the emergency\n broadcast system. \u26a0
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### Escape Sequences
In non-raw strings, escape sequences are processed as follows:

    | Sequence        | Description                                           |
    |:----------------|:------------------------------------------------------|
    | `\b`            | Backspace                                             |
    | `\f`            | Form feed                                             |
    | `\n`            | New line                                              |
    | `\r`            | Carriage return                                       |
    | `\t`            | Horizontal tab                                        |
    | `\uXXXX`        | Unicode character from four hexadecimal digits        |
    | `\uXXany`       | Not a legal Unicode escape; yields `uXXany`           |
    | `\u{X...}`      | Unicode character from 1-8 hexadecimal digits         |
    | `\u{}`          | Not a legal Unicode escape; yields `u{}`              |
    | `\u{123456790}` | Not a legal Unicode escape; yields `u{1234567890}`    |
    | `\X`            | Yields any character verbatim, such as `\'` or `\\`   |


### String Concatenation
In order to support human-readable long strings, the `+` operator may be used to construct
concatenations. For example:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    {
        strBlock: "Knock knock.\n"
                + "Who's there?\n"
                + "Bug in your state machine.\n"
                + "Who's there?\n"
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Strings may include the source line terminators. However, this will capture exactly the actual line
endings used in the LSON source.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    {
        strBlock: "
          Knock knock.
          Who's there?
          Bug in your state machine.
          Who's there?
        "
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The string defined in the above example includes all whitespace and line endings present between the
opening and closing `"` characters.


Elements
----------------------------------------------------------------------------------------------------
LSON really has a single value type: the _element_. Unlike JSON, any string-representable value is
supported and handled consistently, but interpretation is up to the decoding application or context.
Applications that do not handle a particular element type natively will process that value using its
string representation, while preserving its (possibly unknown) type. The element type (which might
be "unknown") is preserved when re-encoding after any transformation or transmission.


### Element Types
Elements have two components: type and value. The element type is optional, and defaults to
"unknown" if not specified. At its most basic, an element has the following syntax:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    ( type : value )
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Elements with a declared type may take several forms. For example:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    (type:value)                // Type "type", value "value"
    ("thing" : "xyzzy")         // Type "thing", value "xyzzy"
    (color:#f863b2)             // Type "color", value "#f863b2"
    ( float32 : 334.1 )         // Type "float32", value "334.1"
    (readyState: armed)         // Type "readyState", value "armed"
    ( a b c : This is a test )  // Type "a b c", value "This is a test"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that leading and trailing whitespace is ignored, and not considered part of the type or value.
However, both types and values may themselves _contain_ whitespace. Quoting can be used to preserve
leading or trailing whitepace in types or values.

Type IDs are case-insensitive, and followed by a colon. (Thus, type names must either be quoted or
escape any contained colons.) Once the first colon is encountered, any subsequent colon is
interpreted as part of the value. Types may be omitted. If the type is omitted, the colon itself may
be present or omitted. The following are equivalent examples of an _untyped_ element, both with
value `"a:b:c"`:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    ("a:b:c")
    (:a:b:c)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The first colon after an element open parentheses is treated as terminating the element's type. All
subsequent colons are considered part of the element value. For example, if a element has type
`width:height` and value `150:400`, it could be expressed in any of the following ways:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    (width\:height: 150:400)
    ("width:height": 150:400)
    ('150:400')                 // Omitted type
    (150\:400)                  // Omitted type
    (:150:400)                  // Omitted type
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In general, either avoid or quote type names with colons. Untyped values with colons are easy enough
to specify using the last form above for unspecified types, with a colon immediately following the
opening parenthesis.


### Element Values
As shown in examples above, the element value may be either unquoted or quoted in its entirety.
Quoted element values obey the conventions outlined in [Strings][], using any of the six string
delimiters. Because elements may contain values of foreign syntax, **LSON interprets any contained
`)` character as the element terminator**. Consider the following (**erroneous**) example:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    ( gronkScript: konst force ← "gravity(2.3)"; konst elapsed ← 1.223; )    // ERROR
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As soon as the LSON parser encounters `konst`, it parses the element value as an unquoted string. In
that mode, it will terminate the element value at `2.3`, _not_ at `1.223;`. Elements that might
contain complex values should therefore either be quoted entirely, or contained in
[Element Value Blocks][] (described below).


### The Null Element
The special element `()` represents an empty, or null element.


### Elements of Type String
As pointed out earlier, strings are the only element type that LSON recognizes implicitly. Since
strings are natively supported, string quotes are sufficient to recognize the element type
("string") and value (the quoted content). Thus, the following are all equivalent:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    (string:"This is a string.")    // Fully-qualified element of type "string"
    (string: This is a string)      // Value quotes optional when inside parentheses
    "This is a string"              // Value recognized as type "string"
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### Element Value Blocks
As noted above, an _element_ is bascially an arbitrary foreign syntactic structure. Most uses of
LSON elements will be for simple values in other domains, as we've seen above. Some elements,
however, might have quite a complex representation, both in syntax and in length. For example, it
should be simple to embed a 250-line script inside LSON. In my experience, I've seen JSON inside a
script inside JSON (not because it's good, but because it's necessary).

To this end, elements may employ block delimiters, using a locally-unique identifier.
Block-delimited elements begin with `((id` where `id` is an arbitrary string. As soon as the
character sequence `id))` is encountered, the element is closed.

Here's an example of a complex element with block delimiters:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    frotz: ((xyzzy python :
        db = MySQLdb.connect("localhost","username","password","dbname")
        cursor = db.cursor()
        sql = "select Column1,Column2 from Table1"
        cursor.execute(sql)
        results = cursor.fetchall()

        for row in results:
            print row[0]+row[1]

        db.close()
    xyzzy))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that the closing identifier must have the identical case as the opening identifier. For
example, `GREEN))` matches `((GREEN`, but not `((Green`.

Now consider the following (**erroneous**) LSON fragment:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    frotz: ((Klaatu blargScript :
        gargle("Hey, I have a ((Klaatu)) inside me!")
    Klaatu))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The element above terminates at `Klaatu))` inside the string, not at the last line (thus yielding a
syntax error). This strict syntax is actually an advantage, because it leaves the element value free
to use any arbitrary syntax, and LSON will dutifully accumulate the string representation of that
element until it encounters the element block terminator.

As another example of the syntactic freedom, here's a fragment that totally diverges from LSON
syntax:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    frotz: ((barada niktoScript:
        Look! Unterminated string chars: " ' » )
        ... wait, there's more ...
        ] } %> #>
        Zing!
    barada))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Safe and legal.

As a final note, because element values encode a foreign syntax, language constructs such as
linefeeds, whitespace, and comments are all interpreted **literally** as part of the element value.
Thus:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    jimjam: ((block someScript:
        (1.2 / 3 * (25.6))    // I am not an LSON comment.
    block))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

is equivalent to:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    jimjam: (someScript: "\n        (1.2 / 3 * (25.6))    // I am not an LSON comment.\n    ")
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### Decoding Elements
All elements have a string representation of their value. In addition, for elements with declared
type, decoders may use this information to generate a native value of that type. For example, the
element `(boolean:true)` always has the string representation "true", and may have a decoder's
native Boolean value `True`. Decoders are thus domain-specific, and may handle a mix of elements of
both known and unknown types. This approach to typing allows unknown types to be handled
consistently across encode-decode transitions, and across data queries and transforms.

In this manner, a C++ decoder could meaningfully and consistently operate on LSON intended for a
Python endpoint, with values like `False` or `None`.


### Untyped Elements
Elements may omit type information, as in `(1.23456)` or `(:s/ab/xy/g)`. As for all elements, both
of these cases have their string representation. However, decoders will typically be able to deduce
the type of an element, according to a scheme of their choosing. For some element types and
decoders, this can be fairly trivial:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    (nullptr) → (nullptr:nullptr)     // C++
    (true) → (bool:true)              // C++
    (true) → (Boolean:true)           // JavaScript
    (true) → (Boolean:True)           // Python
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A JSON-style decoder might employ a sequence of three recognizers:

  1. null
  2. boolean
  3. number

Other common types may have associated type recognizers:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LSON
    (-1.234e6) → (Number:-1.234e6)    // JavaScript
    (-1.234e6) → (double:-1.234e6)    // C++
    (1..10) → (range:"range(1,10)")   // Python
    (#a3f4b9) → (color:0xa3f4b9ff)    // CSS color in C++
    (0x3ff0'0000'0000'0000) ...       // In C++, could be recognized as `uint64_t`
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One reasonable approach for decoders is to maintain an ordered list of recognizers that are employed
in sequence to attempt to recognize a given untyped value. Enumerations such as `true`, `false`,
`null`, `None` and so forth would be first in the list, with more complicated types (like numbers,
colors, regular expressions) tried later in the sequence.

Note that values need only be recognized if the decoder intends to perform native operations with
those values. Decoders that just perform queries, transforms, or transmission need not care about
underlying implementations.

By convention, elements that are consumed and unmodified should be preserved exactly across
decode-encode transitions. For example, the element `(true)` might be interpreted by a Python
decoder as element of type `Boolean`, value `True`. If it's not modified, however, any subsequent
encoding should emit the original `(true)` form. That leaves it free for natural consumption by a
C++ application, for example, while preserving the original meaning (an untyped element with value
`"true"`).



[Default Table Values]: #datastructures/tables/defaulttablevalues
[Element Types]:        ./ElementTypes.md
[Element Value Blocks]: #datavalues/elements/elementvalueblocks
[Strings]:              #strings
[Unicode whitespace]:   https://en.wikipedia.org/wiki/Whitespace_character#Unicode

<link href="https://fonts.googleapis.com/css?family=Mukta|Ubuntu|Roboto+Mono" rel="stylesheet">

<style>
    body {
      background: #f4f4f4;
    }
    .md h1, .md h2, .md h3, .md h4, .md h5, .md h6 {
        border: none;
        font-family: Mukta,Georgia;
    }
    .md h1 {
        margin-top: 1.25em;
        font-size: 200%;
        color: #333;
        font-variant: small-caps;
    }
    .md h2 {
        font-size: 165%;
        color: #333;
        font-variant: small-caps;
    }
    .md h3 {
        font-size: 125%;
        /* font-style: italic; */
        font-weight: normal;
    }
    code {
        background: #e8e4f8;
    }
    pre.listing.tilde {
        background: #ecf8ec;
        border: solid 2px #dddddd;
        padding: 1ex;
    }
    pre.listing code {
        background: #ecf8ec;
    }
    .md a {
        font-family: Mukta,Georgia,Palatino,serif;
    }
    .md code {
        font-family: 'Roboto Mono',Menlo,Consolas,Monospace;
        font-size: 85%;
    }
    .md pre code {
        font-size: 80%;
    }
    .md {
        font-family: Mukta,Georgia;
    }
    div.longTOC div.tocHeader {
        display: none;
    }
    div.longTOC {
        padding: 0 4ex;
        border: solid 2px #eeeeee;
    }
    div.longTOC .level2 {
        margin-left: 3ex;
    }
    div.longTOC .level3 {
        margin-left: 6ex;
    }
</style>

<!-- Markdeep ================================================================================== -->

<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<!-- <script src="markdeep.min.js"></script> -->
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

                                                               <!-- vim: set filetype=markdeep : -->
